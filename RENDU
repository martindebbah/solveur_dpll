                      Mini-projet 1 : solveur DPLL récursif
                             fichier RENDU
                       (à remplir obligatoirement)

**Un mini-projet sans fichier RENDU rempli ne recevra pas de note.**

Date limite: 28 octobre 2022, 23h59

Identité
--------
Nombre de binôme: 60
Nom, prénom 1: CHERIFI Rayan
Nom, prénom 2: DEBBAH Martin


Questions sur votre code
------------------------
0. Avez-vous testé que `make dpll` s'exécute sans erreurs ou warnings,
   et que ensuite `./dpll sudoku-4x4.cnf` donne la réponse attendue (voir
   fichier README) ?

**à remplir**

---

1. Avez-vous utilisé la fonction `filter_map` (donné dans dpll.ml)
   dans votre implémentation de `simplifie` ? 
   - Si oui, expliquez en quelques phrases en français comment vous
     l'avez utilisée.
   - Si non, expliquez en quelques phrases en français comment
     fonctionne votre implémentation de `simplifie`.

   Nous avons utilisé la fonction List.filter_map disponible dans la bibliothèque List de Ocaml. 
(Cette implémentation nous permet d'avoir la liste dans le même sens que celle de départ)
Le filtre permet de renvoyer la clause de départ sans le littéral passé en paramètres.
Ensuite nous faisons une comparaispn entre la clause de départ et celle de retour (avec List.equal). Si elles sont équivalentes,
c'est que le littéral n'était pas présent dans la clause de départ (on ne peut pas la simplifier),
on l'insère donc dans la liste de clauses que 'simplifie' retourne sinon on la simplifie et on ne l'ajoute pas.

---

2. Pour l'implémentation de `unitaire`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ? (Par une
   fonction auxiliaire, on entend ici soit une fonction d'une
   bibliothèque, par exemple des fonctions comme `List.length`,
   `List.rev_append`, ou une fonction `aux_unitaire` que vous avez
   écrite vous-mêmes.) Expliquez en quelques phrases en français
   comment ces fonctions auxiliaires sont utilisées dans votre
   implémentation de la fonction `unitaire`.

   Nous n'avons pas utilisé de fonction auxiliaire. On utilise un 'match' sur chaque clause de l'ensemble des clauses.
   Si l'une d'entre elles correspond à x :: [], c'est qu'elle ne contient qu'un seul littéral, donc qu'elle est unitaire.
   Dans ce cas on retourne x, sinon on appelle récursivement 'unitaire' jusqu'à que clauses corresponde à [].
   Si ce cas est atteint, on lève alors l'exception demandée.

---

3. Pour l'implémentation de `pur`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ?  Expliquez en
   quelques phrases en français comment ces fonctions auxiliaires sont
   utilisées dans votre implémentation de la fonction `pur`.

**à remplir**

---

4. Donnez un exemple d'une formule pour laquelle les deux fonctions
   `solveur_split` et `solveur_dpll_rec` ont un comportement
   différent, et expliquez les différences entre ces deux fonctions.

**à remplir**

---

5. Avez-vous d'autres remarques sur votre rendu ? (question optionnelle)

**à remplir**

---

--fin du fichier RENDU--